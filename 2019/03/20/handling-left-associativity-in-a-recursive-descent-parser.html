<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Handling Left Associativity in a Recursive Descent Parser | Jacob McGladdery’s Blog</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Handling Left Associativity in a Recursive Descent Parser" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction" />
<meta property="og:description" content="Introduction" />
<link rel="canonical" href="https://jcube001.github.io/2019/03/20/handling-left-associativity-in-a-recursive-descent-parser.html" />
<meta property="og:url" content="https://jcube001.github.io/2019/03/20/handling-left-associativity-in-a-recursive-descent-parser.html" />
<meta property="og:site_name" content="Jacob McGladdery’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-03-20T04:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Handling Left Associativity in a Recursive Descent Parser" />
<meta name="google-site-verification" content="mbPn1tZpiKpmSaog5znljhIfEl94qJ-oFP25G_Y-Yu8" />
<script type="application/ld+json">
{"description":"Introduction","mainEntityOfPage":{"@type":"WebPage","@id":"https://jcube001.github.io/2019/03/20/handling-left-associativity-in-a-recursive-descent-parser.html"},"url":"https://jcube001.github.io/2019/03/20/handling-left-associativity-in-a-recursive-descent-parser.html","@type":"BlogPosting","headline":"Handling Left Associativity in a Recursive Descent Parser","dateModified":"2019-03-20T04:00:00+00:00","datePublished":"2019-03-20T04:00:00+00:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css">
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="alternate icon" type="image/png" href="/favicon.png"><link type="application/atom+xml" rel="alternate" href="https://jcube001.github.io/feed.xml" title="Jacob McGladdery's Blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Jacob McGladdery&#39;s Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Handling Left Associativity in a Recursive Descent Parser</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-03-20T04:00:00+00:00" itemprop="datePublished">Mar 20, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="introduction">Introduction</h1>

<p>I recently decided to try implementing a recursive descent parser for a simple arithmetic expression language in C++. I did this partly as a learning exercise as well as to gain better insight into how I may be able to apply object-oriented design patterns when developing a compiler front-end or data deserializer.</p>

<p>First, I came up with a simple grammar for arithmetic expressions and wrote it down in EBNF. Then, I naively began implementing a recursive descent parser for it. The pattern I followed for implementing the parser is similar to the one described on the Wikipedia page for a <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">recursive descent parser</a>. In my design, the lookahead token is a member variable of the Parser class and each production rule in the grammar has a corresponding private method, also located in the Parser class. The production rule methods each return the part of the abstract syntax tree which they are meant to recognize. This way, the entire tree is built using potentially recursive calls from one production rule to another, just like how the EBNF grammar is written.</p>

<p>It’s actually pretty straightforward. Even operator precedence is handled properly by nesting higher precedence operators further down the production rules. At least, it seemed straightforward until I unit-tested and discovered incorrect parse trees were being generated. The problem was I wasn’t building left-associative trees for left-associative operators. Instead, I was making the entire tree right-associative because that is the inherent nature of a recursive descent parser. This problem has been <a href="https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers">talked about before</a>, but I wanted to share my experience with implementing a solution in C++.</p>

<h2 id="initial-implementation">Initial Implementation</h2>

<p>The first implementation I came up with used recursion exclusively to build the parse tree from left-to-right. The recursion used here was just meant as a form of looping since the production rule is calling itself to build the right side of the binary operator. The <code class="language-plaintext highlighter-rouge">Parser::term()</code> function was implemented the same way.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Ast</span><span class="o">::</span><span class="n">Expression</span><span class="o">&gt;</span> <span class="n">Parser</span><span class="o">::</span><span class="n">expression</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">term</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">(</span><span class="n">ID</span><span class="o">::</span><span class="n">Plus</span><span class="p">,</span> <span class="n">ID</span><span class="o">::</span><span class="n">Minus</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">op</span> <span class="o">=</span> <span class="n">binaryOperator</span><span class="p">();</span>
        <span class="n">op</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">tree</span><span class="p">);</span>
        <span class="n">op</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">expression</span><span class="p">();</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">tree</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note, the <code class="language-plaintext highlighter-rouge">Parser::binaryOperator()</code> function is just a factory function which creates an instance of the correct type of <code class="language-plaintext highlighter-rouge">BinaryOperator</code> subclass based on the current token ID.</p>

<h2 id="the-problem">The Problem</h2>

<p>The problem with the initial approach is it inadvertently built the expression and term subtrees from right-to-left, not left-to-right. What was happening was, each recursive call to <code class="language-plaintext highlighter-rouge">Parser::expression()</code> would nest the next terminal or expression under the right side of the current binary operator. Thus, higher precedence was always given to the right side of every expression.</p>

<p>Here’s an example of how the expression <code class="language-plaintext highlighter-rouge">4 - 2 - 1</code> would be parsed using the initial implementation. The resulting parse tree is expressed as an <a href="https://en.wikipedia.org/wiki/S-expression">S-expression</a>.</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="mi">4</span><span class="p">)</span>             <span class="c1">; Got 4</span>
<span class="p">(</span><span class="nb">-</span> <span class="mi">4</span> <span class="no">nil</span><span class="p">)</span>       <span class="c1">; Subtraction, previous tree becomes the left side expression</span>
<span class="p">(</span><span class="nb">-</span> <span class="mi">4</span> <span class="mi">2</span><span class="p">)</span>         <span class="c1">; Got 2, current tree sets the number as the right side expression</span>
<span class="p">(</span><span class="nb">-</span> <span class="mi">4</span> <span class="p">(</span><span class="nb">-</span> <span class="mi">2</span> <span class="no">nil</span><span class="p">))</span> <span class="c1">; Subtraction, set it to the right side of the current tree, and the previous right side becomes its left side</span>
<span class="p">(</span><span class="nb">-</span> <span class="mi">4</span> <span class="p">(</span><span class="nb">-</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">))</span>   <span class="c1">; Got 1, number goes to the right side again</span>
</code></pre></div></div>

<p>The resulting tree would be evaluated in depth-first order meaning an incorrect result of <code class="language-plaintext highlighter-rouge">4 - (2 - 1) = 4 - 1 = 3</code> would be produced.</p>

<h2 id="refined-implementation">Refined Implementation</h2>

<p>For the next implementation, I realized I needed to make each of the expression and term operators left associative. To accomplish this, I needed to make sure the left side of each expression and term were moved deeper in the tree as each new infix operator was encountered. What I came up with is a loop that moves each previously encountered parse tree down the left side of the current and top-most expression, all while only maintaining a pointer to that top-most expression (the tree).</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Ast</span><span class="o">::</span><span class="n">Expression</span><span class="o">&gt;</span> <span class="n">Parser</span><span class="o">::</span><span class="n">expression</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">term</span><span class="p">();</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">match</span><span class="p">(</span><span class="n">ID</span><span class="o">::</span><span class="n">Plus</span><span class="p">,</span> <span class="n">ID</span><span class="o">::</span><span class="n">Minus</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// Changed to a while loop</span>
        <span class="k">auto</span> <span class="n">op</span> <span class="o">=</span> <span class="n">binaryOperator</span><span class="p">();</span>
        <span class="n">op</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">tree</span><span class="p">);</span>
        <span class="n">op</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">term</span><span class="p">();</span>              <span class="c1">// No direct recursion here</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">tree</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The result is a parse tree where expressions that appear first when being parsed also appear properly nested and on the left side of the tree. Below is the example expression <code class="language-plaintext highlighter-rouge">4 - 2 - 1</code> shown parsed correctly using the refined implementation.</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="mi">4</span><span class="p">)</span>             <span class="c1">; Got 4</span>
<span class="p">(</span><span class="nb">-</span> <span class="mi">4</span> <span class="no">nil</span><span class="p">)</span>       <span class="c1">; Subtraction, previous tree becomes the left side expression</span>
<span class="p">(</span><span class="nb">-</span> <span class="mi">4</span> <span class="mi">2</span><span class="p">)</span>         <span class="c1">; Got 2, current tree sets the number as the right side expression</span>
<span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nb">-</span> <span class="mi">4</span> <span class="mi">2</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span> <span class="c1">; Subtraction, previous tree becomes the left side expression again</span>
<span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nb">-</span> <span class="mi">4</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1">; Got 1, number goes to the right side again</span>
</code></pre></div></div>

<p>Since the resulting tree is evaluated depth-first, a correct result of <code class="language-plaintext highlighter-rouge">(4 - 2) - 1 = 2 - 1 = 1</code> would be produced.</p>

  </div><a class="u-url" href="/2019/03/20/handling-left-associativity-in-a-recursive-descent-parser.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Jacob McGladdery&#39;s Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Jacob McGladdery&#39;s Blog</li><li><a class="u-email" href="mailto:jacobm117@gmail.com">jacobm117@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/JCube001"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">JCube001</span></a></li><li><a href="https://www.linkedin.com/in/jacobmcgladdery"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">jacobmcgladdery</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>My personal blog about computer science, software engineering, and DevOps.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
